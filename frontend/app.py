import streamlit as st
import pandas as pd
import sys
import os
import time
from datetime import datetime

# Adiciona o caminho do backend para importar o sniffer
backend_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'backend')
if backend_path not in sys.path:
    sys.path.insert(0, backend_path)

# Importa o sniffer diretamente
try:
    from ferramentas.sniffer.sniffer import PacketSniffer, get_network_interfaces
    SNIFFER_AVAILABLE = True
except ImportError as e:
    st.error(f"Erro ao importar sniffer: {e}")
    SNIFFER_AVAILABLE = False

# O st.set_page_config() deve ser a PRIMEIRA chamada do Streamlit no seu script principal.
st.set_page_config(page_title="Ferramentas de Rede", layout="centered")

# Estado global para resultados de captura
if 'capture_results' not in st.session_state:
    st.session_state.capture_results = {
        "is_capturing": False,
        "packets": [],
        "stats": {},
        "last_capture_time": None
    }

# --- Fun√ß√µes para simular as p√°ginas ---
def homepage():
    st.title("üè† P√°gina Inicial")
    st.write("Bem-vindo ao sistema de Ferramentas de Rede!")
    st.info("üì± Aplica√ß√£o totalmente integrada - sem backend externo necess√°rio!")

def sniffer_page():
    st.title("üîç Sniffer de Pacotes")
    st.markdown("Capture e analise o tr√°fego de rede em tempo real")
    
    # Verifica√ß√£o de disponibilidade
    if not SNIFFER_AVAILABLE:
        st.error("‚ùå Sniffer n√£o dispon√≠vel! Verifique se PyShark est√° instalado.")
        st.code("pip install pyshark")
        return
    
    # Layout em colunas para melhor organiza√ß√£o
    col1, col2 = st.columns([2, 1])
    
    with col1:
        st.subheader("üåê Configura√ß√£o de Interface")
        
        # Bot√£o para detectar interfaces
        if st.button("üîç Detectar Interfaces", type="primary"):
            with st.spinner("Detectando interfaces de rede..."):
                try:
                    # Cria inst√¢ncia do sniffer para detectar interfaces
                    temp_sniffer = PacketSniffer()
                    interfaces = temp_sniffer.get_network_interfaces()
                    st.session_state.interfaces = interfaces
                    st.success(f"‚úÖ {len(interfaces)} interfaces detectadas!")
                    
                    # Mostra as interfaces encontradas
                    if interfaces:
                        st.info("üåê Interfaces dispon√≠veis:")
                        for i, iface in enumerate(interfaces):
                            if isinstance(iface, dict):
                                name = iface.get('name', 'N/A')
                                iface_type = iface.get('type', 'N/A')
                                status = iface.get('status', 'N/A')
                                st.text(f"  {i+1}. {iface_type} {name} ({status})")
                            else:
                                st.text(f"  {i+1}. {str(iface)}")
                                
                except Exception as e:
                    st.error(f"‚ùå Erro ao detectar interfaces: {str(e)}")
                    st.session_state.interfaces = []
        
        # Sele√ß√£o de interface
        if 'interfaces' in st.session_state and st.session_state.interfaces:
            interface_options = []
            for i, iface in enumerate(st.session_state.interfaces):
                if isinstance(iface, dict):
                    name = iface.get('name', f'Interface {i+1}')
                    iface_type = iface.get('type', 'N/A')
                    status = iface.get('status', 'N/A')
                    interface_options.append(f"{iface_type} {name} ({status})")
                else:
                    interface_options.append(f"{str(iface)}")
            
            selected_interface = st.selectbox("Escolha a interface:", interface_options)
            
            # Configura√ß√µes de captura
            st.subheader("‚öôÔ∏è Configura√ß√µes de Captura")
            
            col_config1, col_config2 = st.columns(2)
            with col_config1:
                packet_count = st.number_input("N√∫mero de pacotes:", min_value=1, max_value=1000, value=50)
                timeout = st.number_input("Timeout (segundos):", min_value=1, max_value=300, value=30)
            
            with col_config2:
                use_filter = st.checkbox("Usar filtro BPF")
                bpf_filter = ""
                if use_filter:
                    bpf_filter = st.text_input("Filtro BPF:", placeholder="tcp port 80")
            
            # Controles de captura
            st.subheader("üéÆ Controles")
            
            col_start, col_stop = st.columns(2)
            
            with col_start:
                if st.button("üü¢ Iniciar Captura", type="primary"):
                    try:
                        # Verifica se h√° interface selecionada
                        if not selected_interface:
                            st.error("‚ùå Selecione uma interface primeiro!")
                            return
                        
                        # Extrai nome da interface a partir do texto selecionado
                        interface_name = None
                        for iface in st.session_state.interfaces:
                            if isinstance(iface, dict):
                                name = iface.get('name', '')
                                iface_type = iface.get('type', '')
                                status = iface.get('status', '')
                                display_text = f"{iface_type} {name} ({status})"
                                
                                if display_text == selected_interface:
                                    interface_name = iface.get('id', name)
                                    break
                        
                        if not interface_name:
                            st.error("‚ùå N√£o foi poss√≠vel identificar a interface selecionada!")
                            return
                        
                        # Configura captura
                        st.session_state.capture_results["is_capturing"] = True
                        
                        with st.spinner("Capturando pacotes..."):
                            try:
                                # Cria sniffer
                                sniffer = PacketSniffer()
                                
                                # Executa captura diretamente (sem thread)
                                result = sniffer.start_capture(
                                    interface=interface_name,
                                    packet_count=packet_count,
                                    timeout=timeout,
                                    bpf_filter=bpf_filter if use_filter else None
                                )
                                
                                # Atualiza resultados
                                st.session_state.capture_results.update({
                                    "is_capturing": False,
                                    "packets": result.get('packets', []),
                                    "stats": result.get('stats', {}),
                                    "last_capture_time": datetime.now()
                                })
                                
                                packets_count = len(result.get('packets', []))
                                if result.get('demo_mode'):
                                    st.info(f"‚ÑπÔ∏è Modo demonstra√ß√£o - {packets_count} pacotes simulados")
                                elif result.get('timeout'):
                                    st.warning(f"‚ö†Ô∏è Timeout na captura - {packets_count} pacotes capturados")
                                else:
                                    st.success(f"‚úÖ Captura conclu√≠da! {packets_count} pacotes capturados")
                                    
                                st.rerun()
                                
                            except Exception as e:
                                st.session_state.capture_results.update({
                                    "is_capturing": False,
                                    "error": str(e)
                                })
                                st.error(f"‚ùå Erro na captura: {str(e)}")
                            
                    except Exception as e:
                        st.error(f"‚ùå Erro ao configurar captura: {str(e)}")
                        st.session_state.capture_results["is_capturing"] = False
            
            with col_stop:
                if st.button("üî¥ Parar Captura"):
                    st.session_state.capture_results["is_capturing"] = False
                    st.success("üî¥ Captura interrompida!")
    
    with col2:
        st.subheader("üìä Status da Captura")
        
        # Status em tempo real
        if st.session_state.capture_results["is_capturing"]:
            st.warning("ÔøΩ Captura sendo configurada...")
        else:
            st.success("ÔøΩ Pronto para capturar")
        
        # M√©tricas da √∫ltima captura
        if st.session_state.capture_results.get("last_capture_time"):
            st.metric("√öltima captura", 
                     st.session_state.capture_results["last_capture_time"].strftime("%H:%M:%S"))
        
        if st.session_state.capture_results.get("packets"):
            st.metric("Pacotes capturados", len(st.session_state.capture_results["packets"]))
    
    # Resultados da captura
    if st.session_state.capture_results.get("packets"):
        st.subheader("üìã Resultados da Captura")
        
        packets = st.session_state.capture_results["packets"]
        
        if packets:
            # Estat√≠sticas gerais
            st.success(f"‚úÖ {len(packets)} pacotes capturados")
            
            # Tabela de pacotes
            try:
                packet_data = []
                for i, packet in enumerate(packets[:100]):  # Limitar a 100 para performance
                    packet_info = {
                        'ID': i + 1,
                        'Timestamp': packet.get('timestamp', 'N/A'),
                        'Protocolo': packet.get('protocol', 'N/A'),
                        'Origem': packet.get('src', 'N/A'),
                        'Destino': packet.get('dst', 'N/A'),
                        'Tamanho': packet.get('length', 'N/A')
                    }
                    packet_data.append(packet_info)
                
                if packet_data:
                    df = pd.DataFrame(packet_data)
                    st.dataframe(df, use_container_width=True)
                    
                    # Estat√≠sticas por protocolo
                    protocols = [p.get('protocol', 'Desconhecido') for p in packets]
                    protocol_counts = pd.Series(protocols).value_counts()
                    
                    st.subheader("üìà Estat√≠sticas por Protocolo")
                    col_chart1, col_chart2 = st.columns(2)
                    
                    with col_chart1:
                        st.bar_chart(protocol_counts)
                    
                    with col_chart2:
                        for protocol, count in protocol_counts.head(5).items():
                            st.metric(str(protocol), count)
                
            except Exception as e:
                st.error(f"‚ùå Erro ao processar dados: {str(e)}")
        
        # Bot√£o para limpar resultados
        if st.button("üóëÔ∏è Limpar Resultados"):
            st.session_state.capture_results = {
                "is_capturing": False,
                "packets": [],
                "stats": {},
                "last_capture_time": None
            }
            st.success("‚úÖ Resultados limpos!")
            st.rerun()
    
    # Erro se houver
    if 'error' in st.session_state.capture_results:
        st.error(f"‚ùå Erro na captura: {st.session_state.capture_results['error']}")

def dashboard_page():
    """
    P√°gina do dashboard com overview das ferramentas
    """
    st.title("üìä Dashboard - Ferramentas de Rede")
    st.markdown("**Vis√£o geral do sistema e ferramentas dispon√≠veis**")
    
    # M√©tricas principais
    st.subheader("üìà Status do Sistema")
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("Sistema", "üü¢ Online", delta="Funcionando")
    
    with col2:
        st.metric("Sniffer", "‚úÖ Dispon√≠vel" if SNIFFER_AVAILABLE else "‚ùå Indispon√≠vel")
    
    with col3:
        total_interfaces = len(getattr(st.session_state, 'interfaces', []))
        st.metric("Interfaces", total_interfaces)
    
    with col4:
        total_packets = len(st.session_state.capture_results.get("packets", []))
        st.metric("Pacotes Capturados", total_packets)
    
    # Se√ß√£o de ferramentas dispon√≠veis
    st.subheader("üõ†Ô∏è Ferramentas Dispon√≠veis")
    
    tool_col1, tool_col2 = st.columns(2)
    
    with tool_col1:
        st.info("üîç **Sniffer de Pacotes**")
        st.write("Capture e analise tr√°fego de rede em tempo real")
    
    with tool_col2:
        st.info("üìà **Speed Test**")
        st.write("Teste a velocidade da sua conex√£o")
    
    # Hist√≥rico recente
    if st.session_state.capture_results.get("last_capture_time"):
        st.subheader("üìã √öltima Atividade")
        
        last_time = st.session_state.capture_results["last_capture_time"]
        packets = st.session_state.capture_results.get("packets", [])
        
        st.success(f"‚úÖ √öltima captura: {last_time.strftime('%H:%M:%S')} - {len(packets)} pacotes")
        
        # Resumo r√°pido dos protocolos
        if packets:
            protocols = [p.get('protocol', 'Desconhecido') for p in packets]
            protocol_counts = pd.Series(protocols).value_counts().head(3)
            
            st.write("**Top 3 Protocolos:**")
            for protocol, count in protocol_counts.items():
                st.text(f"‚Ä¢ {protocol}: {count} pacotes")
    
    # Ajuda r√°pida
    st.subheader("üí° Ajuda R√°pida")
    
    with st.expander("Como usar o Sniffer"):
        st.markdown("""
        1. **V√° para a p√°gina Sniffer** üîç
        2. **Detecte interfaces** dispon√≠veis
        3. **Configure** filtros se necess√°rio
        4. **Inicie a captura** e monitore em tempo real
        5. **Analise os resultados** na tabela e gr√°ficos
        """)
    
    with st.expander("Filtros BPF √öteis"):
        st.code("""
        tcp port 80          # Tr√°fego HTTP
        tcp port 443         # Tr√°fego HTTPS
        udp port 53          # DNS
        icmp                 # Ping
        tcp and port 22      # SSH
        """)
    
    # Status das interfaces
    if hasattr(st.session_state, 'interfaces') and st.session_state.interfaces:
        st.subheader("üåê Interfaces Dispon√≠veis")
        
        for i, iface in enumerate(st.session_state.interfaces[:5]):  # Mostrar s√≥ as 5 primeiras
            if isinstance(iface, dict):
                name = iface.get('name', f'Interface {i+1}')
                status = "üü¢ Ativa" if iface.get('status') else "‚ö™ Detectada"
                st.text(f"‚Ä¢ {name} - {status}")
            else:
                st.text(f"‚Ä¢ {str(iface)}")
        
        if len(st.session_state.interfaces) > 5:
            st.text(f"... e mais {len(st.session_state.interfaces) - 5} interfaces")
    else:
        st.info("üí° V√° para a p√°gina Sniffer para detectar interfaces de rede")

def speedtest_page():
    st.title("üìä Speed Test")
    st.write("Teste de velocidade da sua conex√£o.")
    st.info("üöß Speed Test em desenvolvimento")
    
    # Placeholder para speedtest
    if st.button("üöÄ Executar Speed Test"):
        st.info("Funcionalidade em desenvolvimento. Em breve dispon√≠vel!")

def about_page():
    st.title("‚ÑπÔ∏è Sobre o Projeto")
    st.write("**Ferramentas de Redes** - Um conjunto completo de utilit√°rios para an√°lise e monitoramento de rede.")
    
    st.markdown("""
    ### üöÄ Funcionalidades:
    - **üîç Sniffer de Pacotes**: Captura e an√°lise de tr√°fego de rede em tempo real
    - **üìä Dashboard**: Visualiza√ß√£o centralizada de m√©tricas e status
    - **üìà Speed Test**: Teste de velocidade da conex√£o
    
    ### üõ†Ô∏è Tecnologias:
    - **Frontend**: Streamlit
    - **Captura de Pacotes**: PyShark
    - **Visualiza√ß√£o**: Pandas, Streamlit Charts
    
    ### üìù Como usar:
    1. Acesse o Dashboard para ver o status geral
    2. Use o Sniffer para capturar e analisar pacotes
    3. Teste a velocidade da sua conex√£o no Speed Test
    """)

# --- L√≥gica de Navega√ß√£o na Barra Lateral ---
st.sidebar.title("üåê Navega√ß√£o")
st.sidebar.markdown("---")
page = st.sidebar.radio("Escolha uma p√°gina:", ["üè† In√≠cio", "üìä Dashboard", "üîç Sniffer", "üìà SpeedTest", "‚ÑπÔ∏è Sobre"])

# Navega√ß√£o principal
if page == "üè† In√≠cio":
    homepage()
elif page == "üìä Dashboard":
    dashboard_page()
elif page == "üîç Sniffer":
    sniffer_page()
elif page == "üìà SpeedTest":
    speedtest_page()
elif page == "‚ÑπÔ∏è Sobre":
    about_page()

# Rodap√© informativo na sidebar
st.sidebar.markdown("---")
st.sidebar.markdown("### üîó Status do Sistema")

# Status da aplica√ß√£o integrada
st.sidebar.success("‚úÖ Aplica√ß√£o Integrada")
st.sidebar.info("üí° Sniffer totalmente integrado - sem backend externo necess√°rio")

# Informa√ß√µes do projeto
st.sidebar.markdown("---")
st.sidebar.markdown("**Ferramentas de Redes v2.0**")
st.sidebar.markdown("*Vers√£o totalmente integrada*")
